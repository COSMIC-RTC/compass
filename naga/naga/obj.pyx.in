<?py
import re
import datetime

now = datetime.datetime.now()
template_strs = [
    'CLASSNAME',
    'DIM',
    'C_TYPE',
    'NUMPY_TYPENAME_T',
    'NUMPY_TYPENAME',
    'CAST',
    'C_FFT_TYPE',
    'PY_FFT_TYPE']
template_type_str = 'ARRAY_TYPE'
c_types_info = {
    'int1': ['Int', '1', 'int', 'np.int32_t', 'np.int32', 'SIMPLE', '', '', []],
    'int2': ['Int', '2', 'int', 'np.int32_t', 'np.int32', 'SIMPLE', '', '', []],
    'int3': ['Int', '3', 'int', 'np.int32_t', 'np.int32', 'SIMPLE', '', '', []],
    'int4': ['Int', '4', 'int', 'np.int32_t', 'np.int32', 'SIMPLE', '', '', []],
    'unsigned int1': ['UInt', '1', 'unsigned int', 'np.uint32_t', 'np.uint32', 'SIMPLE', '', '', []],
    'unsigned int2': ['UInt', '2', 'unsigned int', 'np.uint32_t', 'np.uint32', 'SIMPLE', '', '', []],
    'unsigned int3': ['UInt', '3', 'unsigned int', 'np.uint32_t', 'np.uint32', 'SIMPLE', '', '', []],
    'unsigned int4': ['UInt', '4', 'unsigned int', 'np.uint32_t', 'np.uint32', 'SIMPLE', '', '', []],

    'float1': ['Float', '1', 'float', 'np.float32_t', 'np.float32', 'SIMPLE', 'cuFloatComplex', 'ComplexS', []],
    'float2': ['Float', '2', 'float', 'np.float32_t', 'np.float32', 'SIMPLE', 'cuFloatComplex', 'ComplexS', []],
    'float3': ['Float', '3', 'float', 'np.float32_t', 'np.float32', 'SIMPLE', 'cuFloatComplex', 'ComplexS', []],
    'float4': ['Float', '4', 'float', 'np.float32_t', 'np.float32', 'SIMPLE', 'cuFloatComplex', 'ComplexS', []],
    'complexS1': ['ComplexS', '1', 'cuFloatComplex', 'np.complex64_t', 'np.complex64', 'COMPLEX', 'float', 'Float', []],
    'complexS2': ['ComplexS', '2', 'cuFloatComplex', 'np.complex64_t', 'np.complex64', 'COMPLEX', 'float', 'Float', []],
    'complexS3': ['ComplexS', '3', 'cuFloatComplex', 'np.complex64_t', 'np.complex64', 'COMPLEX', 'float', 'Float', []],
    'complexS4': ['ComplexS', '4', 'cuFloatComplex', 'np.complex64_t', 'np.complex64', 'COMPLEX', 'float', 'Float', []],

    'double1': ['Double', '1', 'double', 'np.float64_t', 'np.float64', 'SIMPLE', 'cuDoubleComplex', 'ComplexD', []],
    'double2': ['Double', '2', 'double', 'np.float64_t', 'np.float64', 'SIMPLE', 'cuDoubleComplex', 'ComplexD', []],
    'double3': ['Double', '3', 'double', 'np.float64_t', 'np.float64', 'SIMPLE', 'cuDoubleComplex', 'ComplexD', []],
    'double4': ['Double', '4', 'double', 'np.float64_t', 'np.float64', 'SIMPLE', 'cuDoubleComplex', 'ComplexD', []],
    'complexD1': ['ComplexD', '1', 'cuDoubleComplex', 'np.complex128_t', 'np.complex128', 'COMPLEX', 'double', 'Double', []],
    'complexD2': ['ComplexD', '2', 'cuDoubleComplex', 'np.complex128_t', 'np.complex128', 'COMPLEX', 'double', 'Double', []],
    'complexD3': ['ComplexD', '3', 'cuDoubleComplex', 'np.complex128_t', 'np.complex128', 'COMPLEX', 'double', 'Double', []],
    'complexD4': ['ComplexD', '4', 'cuDoubleComplex', 'np.complex128_t', 'np.complex128', 'COMPLEX', 'double', 'Double', []],
}
?>

import numpy as np

assert sizeof(int) == sizeof(np.int32_t)
assert sizeof(float) == sizeof(np.float32_t)
assert sizeof(double) == sizeof(np.float64_t)


"""
#################################################
# C-Class carma_obj
#################################################
cdef extern from "carma_obj.h":
    cdef cppclass carma_obj[T]:
        T *d_data
        int ndim
        long *dims_data
        int nb_elem
        int device
        carma_streams *stream

        carma_obj(carma_obj[T] *obj)
        carma_obj(carma_context *context, const long *dims)
        carma_obj(carma_context *context,carma_obj[T] *obj)
        carma_obj(carma_context *context,long *dims, T *data)

        T* getData()
        T* getDataAt(int index)
        long *getDims()                      #
        long getDimsi "getDims"(int i)
        int getNbElem()                     #
        carma_context *getContext()
        int getDevice()                     #
        bool is_rng_init()                  #

        int host2device(T *data)            #
        int device2host(T *data)            #
        int device2hostOpt(T *data)
        int host2deviceVect(T *data, int incx, int incy)
        int device2hostVect(T *data, int incx, int incy)
        int host2deviceMat(T *data, int lda, int ldb)
        int device2hostMat(T *data, int lda, int ldb)


        int copyInto(T *data, int nb_elem)  #
        int copyFrom(T *data, int nb_elem)  #

        int reset()

        cufftHandle* getPlan()
        unsigned int * getValues()
        T sum()                   # (float and double only)

        int transpose(carma_obj[T] *source) #

  #/**< Cublas V2 */
        int imax(int incx)  #
        int imin(int incx)  #
        T asum(int incx)    #
        T nrm2(int incx)    #
        T dot(carma_obj[T] *source, int incx, int incy)             #
        void scale(T alpha, int incx)                               #
        void swap(carma_obj[T] *source, int incx, int incy)         #
        void copy(carma_obj[T] *source, int incx, int incy)         #
        void axpy(T alpha, carma_obj[T] *source, int incx, int incy)#

#int carma_axpy_cpu<float>(long N, float alpha, float *h_X, long incX,
#    float *h_Y, long incY) {


#        void rot(carma_obj[T] *source, int incx, int incy, T sc, T ss)

        void gemv(char trans, T alpha, carma_obj[T] *matA, int lda,
            carma_obj[T] *vectx, int incx, T beta, int incy)                #
        void ger(T alpha, carma_obj[T] *vectx, int incx,
            carma_obj[T] *vecty, int incy, int lda)                         #
        void symv(cublasFillMode_t uplo, T alpha, carma_obj[T] *matA,
            int lda, carma_obj[T] *vectx, int incx, T beta, int incy)       #

        void gemm(char transa, char transb, T alpha, carma_obj[T] *matA,    #
            int lda, carma_obj[T] *matB, int ldb, T beta, int ldc)
        void symm(cublasSideMode_t side, cublasFillMode_t uplo, T alpha,
            carma_obj[T] *matA, int lda, carma_obj[T] *matB, int ldb,
            T beta, int ldc)                                                #
        void syrk(cublasFillMode_t uplo, char transa, T alpha,
            carma_obj[T] *matA, int lda, T beta, int ldc)                   #
        void syrkx(cublasFillMode_t uplo, char transa, T alpha,
            carma_obj[T] *matA, int lda, carma_obj[T] *matB, int ldb,
            T beta, int ldc)                                                #
        void geam(char transa, char transb, T alpha, carma_obj[T] *matA,
            int lda, T beta, carma_obj[T] *matB, int ldb, int ldc)          #
        void dgmm(cublasSideMode_t side, carma_obj[T] *matA, int lda,
            carma_obj[T] *vectx, int incx, int ldc)                         #

        #/**< Curand */
        int init_prng(int seed)
#        int destroy_prng()
#        int prng(T *output, char gtype, float alpha, float beta)
#        int prng(T *output, char gtype, float alpha)
#        int prng(char gtype, float alpha, float beta)
#        int prng(char gtype, float alpha)
        int prng(char gtype)
        int init_prng_host(int seed)
        int prng_host(char gtype)
#        int prng_host(char gtype, T alpha)
#        int destroy_prng_host()



    cdef void  carma_initfft[T_in, T_out](const long *dims_data, cufftHandle *plan, cufftType tPlan)
    cdef int carma_fft[T_in, T_out](T_in *input, T_out *output, int dir, cufftHandle plan)

    cdef int snapTransformSize(unsigned int dataSize)
    cdef int carma_initfftconv(carma_obj[float] *data_in, carma_obj[float] *kernel_in,
        carma_obj[float] *padded_data, carma_obj[cuFloatComplex] *padded_spectrum, int kernelY, int kernelX)
    cdef int carma_fftconv(carma_obj[float] *data_out, carma_obj[float] *padded_data,
        carma_obj[cuFloatComplex] *padded_spectrum, int kernelY, int kernelX)
"""
# Dictionary fft available:
# Dictionary contain fft input type
# key:   fft output type
# value: cufftType
cdef dict_fft_Float1D = {obj_ComplexS1D: (CUFFT_R2C)}
cdef dict_fft_Float2D = {obj_ComplexS2D: (CUFFT_R2C)}
cdef dict_fft_Float3D = {obj_ComplexS3D: (CUFFT_R2C)}
cdef dict_fft_Float4D = {obj_ComplexS4D: (CUFFT_R2C)}
cdef dict_fft_Double1D = {obj_ComplexD1D: (CUFFT_D2Z)}
cdef dict_fft_Double2D = {obj_ComplexD2D: (CUFFT_D2Z)}
cdef dict_fft_Double3D = {obj_ComplexD3D: (CUFFT_D2Z)}
cdef dict_fft_Double4D = {obj_ComplexD4D: (CUFFT_D2Z)}
cdef dict_fft_ComplexS1D = {
    obj_Float1D: (CUFFT_C2R),
    obj_ComplexS1D: (CUFFT_C2C)
}
cdef dict_fft_ComplexS2D = {
    obj_Float2D: (CUFFT_C2R),
    obj_ComplexS2D: (CUFFT_C2C)
}
cdef dict_fft_ComplexS3D = {
    obj_Float3D: (CUFFT_C2R),
    obj_ComplexS3D: (CUFFT_C2C)
}
cdef dict_fft_ComplexS4D = {
    obj_Float4D: (CUFFT_C2R),
    obj_ComplexS4D: (CUFFT_C2C)
}
cdef dict_fft_ComplexD1D = {
    obj_Double1D: (CUFFT_Z2D),
    obj_ComplexD1D: (CUFFT_Z2Z)
}
cdef dict_fft_ComplexD2D = {
    obj_Double2D: (CUFFT_Z2D),
    obj_ComplexD2D: (CUFFT_Z2Z)
}
cdef dict_fft_ComplexD3D = {
    obj_Double3D: (CUFFT_Z2D),
    obj_ComplexD3D: (CUFFT_Z2Z)
}
cdef dict_fft_ComplexD4D = {
    obj_Double4D: (CUFFT_Z2D),
    obj_ComplexD4D: (CUFFT_Z2Z)
}


<?py


pxd_code_str = '''
##########################################################
#  P-Class `CLASSNAMEDIMD`
#########################################################


cdef class obj_CLASSNAMEDIMD:

    def __cinit__(self,naga_context ctxt=None ,
                  obj_CLASSNAMEDIMD obj=None,
                  np.ndarray[ndim=DIM, dtype=NUMPY_TYPENAME_T] data=None,
                  np.ndarray[ndim=1, dtype=np.int64_t] dims=None,
                  ):
        """obj_CLASSNAMEDIMD constructor.

        obj(obj obj)
        obj(naga_context ctxt, obj obj)
        obj(naga_context ctxt, np.ndarray dims)
        obj(naga_context ctxt, np.ndarray data)

        input data must be a np.ndarray with ndim=DIM
        """

        if (ctxt is None):
            #if no context: copy constructor
            #using the context associated to the obj argument
            if(obj is None):
                raise ValueError("Missing argument naga.context or obj")
            else:
                obj.activateDevice()
                self.c_o=new carma_obj[C_TYPE](obj.c_o)
                self.context=obj.getContext()
            return

        self.context=ctxt

        if(obj is not None):
            #copy constructor
            #using context given in argument
            ctxt.set_activeDevice(obj.getDevice())
            self.c_o = new carma_obj[C_TYPE](ctxt.c,obj.c_o)
            return

        cdef long cdims[DIM+1]
        cdims[0]=DIM
        cdef int i

        if(data is None):
            if(dims is None):
                raise ValueError("Missing argument data (np.array[ndim=DIM]) or dims (np.ndarray[ndim=1])")

            if( dims.shape[0]!=DIM ):
                raise ValueError("Wrong number of dimension: got ",dims.shape[0]," (expected: DIM)")
            for i in range(DIM):
                cdims[i+1]=dims[i]
            #self.c_o= new carma_obj[C_TYPE](ctxt.c,<long*>dims.data)
            self.c_o= new carma_obj[C_TYPE](ctxt.c,cdims)
            return

        cdef np.ndarray data_F=np.asfortranarray(data)
        for i in range(DIM):
            cdims[i+1]=data.shape[i]
        if(data.flags.fortran):
            self.c_o=new carma_obj[C_TYPE](ctxt.c,cdims,<C_TYPE*>data.data)
        else:
            self.c_o=new carma_obj[C_TYPE](ctxt.c,cdims,<C_TYPE*>data_F.data)

    def __dealloc__(self):
        del self.c_o

    def getData_ptr(self):
        """Return the pointer value to the naga data (as an integer, type:uintptr_t)."""
        cdef uintptr_t data_ptr=<uintptr_t>self.c_o.getData()
        return data_ptr


    def getCarma_ptr(self):
        """Return the pointer value to the carma object of the naga (as an integer, type:uintptr_t)."""
        cdef uintptr_t carma_ptr=<uintptr_t>self.c_o
        return carma_ptr


    def get_Dims(self):
        """Return the dimensions of the obj."""

        cdef np.ndarray dims = np.ndarray((DIM+1),dtype=np.int64)
        cdef const long *cdims
        cdef int i
        cdims=self.c_o.getDims()
        for i in range(DIM+1):
            dims[i]=cdims[i]
        return dims[1:DIM+1]


    def getNbElem(self):
        """Return the number of elements of the naga object."""
        return self.c_o.getNbElem()


    def getDevice(self):
        """Return the device used by the current obj."""
        return self.c_o.getDevice()


    def activateDevice(self, int silent=1):
        """Activate the device used by the current obj."""
        cdef int dev = self.c_o.getDevice()
        self.context.set_activeDevice(dev,silent)


    def getContext(self):
        """Return a pointer to the carma_context associated with the current obj."""
        return self.context


    def is_rng_init(self):
        self.c_o.is_rng_init()


    def host2device(self,np.ndarray[ndim=DIM, dtype=NUMPY_TYPENAME_T] data):
        """Copy data from host to device.

        host2device(np.ndarray[ndim=DIM, dtype=NUMPY_TYPENAME_T] data):
        data -- NUMPY_TYPENAME: data to copy from host to device
        """
        self.context.set_activeDeviceForCpy(self.getDevice())
        if(data.flags.fortran):
            self.c_o.host2device(<C_TYPE*>data.data)
            return
        cdef np.ndarray data_F=data.flatten(order="F")
        self.c_o.host2device(<C_TYPE*>data_F.data)


    def device2host(self):
        """Copy data from device to host.

        return np.ndarray(dtype=NUMPY_TYPENAME) of DIM dimension(s)
        """
        sh=self.get_Dims()
        cdef np.ndarray[ dtype=NUMPY_TYPENAME_T, ndim=DIM] res=np.zeros(sh,dtype=NUMPY_TYPENAME)
        cdef np.ndarray[ dtype=NUMPY_TYPENAME_T, ndim=1] tmp=np.zeros(self.c_o.getNbElem(),
                                                                        dtype=NUMPY_TYPENAME)
        self.context.set_activeDeviceForCpy(self.getDevice())
        self.c_o.device2host(<C_TYPE*>tmp.data)
        res=tmp.reshape(sh,order="F")
        return res

    def device2hostOpt(self):
        """Copy data from device o_data to host.

        return np.ndarray(dtype=NUMPY_TYPENAME) of DIM dimension(s)
        """
        sh=self.get_Dims()
        cdef np.ndarray[ dtype=NUMPY_TYPENAME_T, ndim=DIM] res=np.zeros(sh, dtype=NUMPY_TYPENAME)
        cdef np.ndarray[ dtype=NUMPY_TYPENAME_T, ndim=1] tmp=np.zeros(self.c_o.getNbElem(),
                                                                        dtype=NUMPY_TYPENAME)
        self.context.set_activeDeviceForCpy(self.getDevice())
        self.c_o.device2hostOpt(<C_TYPE*>tmp.data)
        res=tmp.reshape(sh,order="F")
        return res


    def copyFrom(self, obj_CLASSNAMEDIMD src):
        """Copy the data from src to the current obj.

        src -- obj_CLASSNAMEDIMD: object to copy the data from.
        """
        if(self.getDevice()!=src.getDevice()):
            raise ValueError("copy only on the same device")
        self.context.set_activeDeviceForCpy(self.getDevice())
        self.c_o.copyFrom( src.c_o.getData(), src.c_o.getNbElem())


    def copyInto(self, obj_CLASSNAMEDIMD dest):
        """Copy data from current obj to dest.

        dest -- obj_CLASSNAMEDIMD: object to copy the data into.
        """
        if(self.getDevice()!=dest.getDevice()):
            raise ValueError("copy only on the same device")
        self.context.set_activeDeviceForCpy(self.getDevice())
        self.c_o.copyInto(dest.c_o.getData(), dest.c_o.getNbElem())

    def reset(self):
        """Set obj to zero.

        """
        self.context.set_activeDeviceForCpy(self.getDevice())
        self.c_o.reset()


    def getValues(self):
        return <np.int64_t> self.c_o.getValues()


'''
pxd_code_str2 = '''
    def imax (self):
        """Cublas amax.

        Return the smallest index of the maximum absolute magnitude element."""
        self.context.set_activeDevice(self.getDevice())
        return self.c_o.imax(1)


    def imin (self):
        """Cublas amin

        Return the smallest index of the minimum absolute magnitude element."""
        self.context.set_activeDevice(self.getDevice())
        return self.c_o.imin(1)


    def dot(self,obj_CLASSNAMEDIMD src):
        """Cublas dot

        src -- obj_CLASSNAMEDIMD
        return the dot product of src and self.
        """
        if(self.getDevice()!=src.getDevice()):
            raise ValueError("dot only on the same device")
        return self.c_o.dot(src.c_o,1,1)


    def scale(self, NUMPY_TYPENAME_T alpha):
        """Cublas scal

        alpha -- NUMPY_TYPENAME: caling factor
        self = alpha.self
        """
        self.context.set_activeDeviceForCpy(self.getDevice())
        cdef C_TYPE a
CASTSIMPLE
        a=alpha
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
ENDCOMPLEX
        self.c_o.scale(a,1)


    def swap(self, obj_CLASSNAMEDIMD src):
        """Cublas swap

        src -- obj_CLASSNAMEDIMD
        Swap data contents of naga objects self and src.
        """
        if(self.getDevice()!=src.getDevice()):
            raise ValueError("swap only on the same device")
        self.context.set_activeDeviceForCpy(self.getDevice())
        self.c_o.swap(src.c_o,1,1)


    def copy(self, obj_CLASSNAMEDIMD src):
        """Cublas copy

        src -- obj_CLASSNAMEDIMD
        Copy data from src into self
        """
        if(self.getDevice()!=src.getDevice()):
            raise ValueError("copy only on the same device")
        self.context.set_activeDeviceForCpy(self.getDevice())
        self.c_o.copy(src.c_o,1,1)


CASTSIMPLE
    def init_prng(self,int seed=1234):
        """Generate random values for this naga datas.

        seed -- integer: seed for random function (default:1234)
        """
        self.c_o.init_prng(seed)
ENDSIMPLE

    def random(self,int seed=1234):
        """Generate random values for this naga datas.

        seed -- integer: seed for random function (default:1234)
        """
        if(not self.c_o.is_rng_init()):
CASTSIMPLE
            self.c_o.init_prng_host(seed)
        self.c_o.prng_host(b'U')
ENDSIMPLE
CASTCOMPLEX
            self.c_o.init_prng(seed)
        self.c_o.prng(b'U')
ENDCOMPLEX

CASTSIMPLE
    def montagn(self, float ta_jolie_maman,int seed=1234):
        """Generate random values for this naga datas.

        seed -- integer: seed for random function (default:1234)
        """
        self.c_o.prng_montagn(ta_jolie_maman)
ENDSIMPLE

'''
pxd_code_str_1D = '''
    def axpy( self, NUMPY_TYPENAME_T alpha, obj_CLASSNAME1D dest=None):
        """cublas axpy

        dest -- obj_CLASSNAME1D
        alpha-- NUMPY_TYPENAME
        beta -- NUMPY_TYPENAME
        Return dest=alpha*self +dest
        """
        if(dest==None):
            c=self.getContext()
            dest=obj_CLASSNAMEDIMD(ctxt=self.getContext(),dims=self.get_Dims())
        if(self.getDevice()!=dest.getDevice()):
            raise ValueError("axpy only on the same device")
        self.context.set_activeDeviceForCpy(self.getDevice())
        cdef C_TYPE a
CASTSIMPLE
        a=alpha
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
ENDCOMPLEX
        dest.c_o.axpy(a,self.c_o,1,1)
        return dest


    def ger(self, obj_CLASSNAME1D Y, NUMPY_TYPENAME_T alpha=1.0,
            obj_CLASSNAME2D A=None):
        """Cublas ger

        Y -- obj_CLASSNAME1D
        alpha -- NUMPY_TYPENAME (default = 1)
        A -- obj_CLASSNAME2D (default = None)

        Return A=alpha*self*t(y)+A
        """
        cdef device=self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimX=self.get_Dims()
        cdef dimY=Y.get_Dims()
        if(A is None):
            dimA=np.ndarray(2,dtype=np.int64)
            dimA[0]=dimY[0]
            dimA[1]=dimX[0]
            A=obj_CLASSNAME2D(self.getContext(),dims=dimA)
        if(device !=Y.getDevice() or
           device !=A.getDevice()):
            raise ValueError(" ger only on the same device")
        cdef C_TYPE a
CASTSIMPLE
        a=alpha
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
ENDCOMPLEX
        A.c_o.ger(a,Y.c_o,1,self.c_o,1,dimY[0])

        return A


'''

pxd_code_str_2D = '''
    def gemv(self, obj_CLASSNAME1D Vx, NUMPY_TYPENAME_T alpha=1,
             obj_CLASSNAME1D Vy=None, NUMPY_TYPENAME_T beta=0 ):
        """Cublas gemv

        Vx -- obj_CLASSNAME1D
        alpha -- NUMPY_TYPENAME (default = 1)
        Vy -- obj_CLASSNAME1D (default = None)
        beta -- NUMPY_TYPENAME (default = 0)
        Return  Vy=alpha*self*Vx+beta*Vy
        """
        device=self.getDevice()
        self.context.set_activeDeviceForCpy(device)
        cdef dimM=self.get_Dims()
        if(Vy is None):
            Vy=obj_CLASSNAME1D(ctxt=self.getContext(),dims=dimM[0:1])

        if( (self.getDevice()!=Vx.getDevice()) or
             self.getDevice()!= Vy.getDevice()):
            raise ValueError("gemv only on the same device")
        cdef C_TYPE a
        cdef C_TYPE b
CASTSIMPLE
        a=alpha
        b=beta
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
        b.x=beta.x
        b.y=beta.y
ENDCOMPLEX

        #Vy.c_o.gemv(b'N',a, self.c_o,dimM[1],Vx.c_o,1,b,1)
        Vy.c_o.gemv(b'N',a, self.c_o,dimM[0],Vx.c_o,1,b,1)

        return Vy


    def symv(self,obj_CLASSNAME1D Vx, NUMPY_TYPENAME_T alpha=1,
             obj_CLASSNAME1D Vy=None , NUMPY_TYPENAME_T beta=0):
        """Cublas symv

        Vx -- obj_CLASSNAME1D
        alpha -- NUMPY_TYPENAME (default = 1)
        Vy -- obj_CLASSNAME1D (default = None)
        beta -- NUMPY_TYPENAME (default = 0)
        Return Vy=alpha*self*Vx+beta*Vy
        """
        cdef device= self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimM=self.get_Dims()
        if(Vy is None):
            #dimY=np.array([1,dimM[1]],dtype=np.int64)
            #Vy=obj_CLASSNAMEDIMD(ctxt=self.getContext(),dims=dimY)
            Vy=obj_CLASSNAMEDIMD(ctxt=self.getContext(),dims=dimM)
        if(device !=Vx.getDevice() or
           device !=Vy.getDevice() ):
            raise ValueError("symv only on the same device")

        cdef C_TYPE a
        cdef C_TYPE b
CASTSIMPLE
        a=alpha
        b=beta
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
        b.x=beta.x
        b.y=beta.y
ENDCOMPLEX
        Vy.c_o.symv(CUBLAS_FILL_MODE_LOWER, a, self.c_o, dimM[0],
                    Vx.c_o, 1, b, 1)

        return Vy


    def gemm(self,obj_CLASSNAME2D B, str opA='n', str opB='n',
             NUMPY_TYPENAME_T alpha=1, obj_CLASSNAME2D C=None, NUMPY_TYPENAME_T beta=0):
        """Cublas gemm

        B -- obj_CLASSNAME2D
        opA -- char (default = 'n')
        opB -- char (default = 'n')
        alpha -- NUMPY_TYPENAME (default = 1)
        C -- obj_CLASSNAME2D (default = None)
        beta  -- NUMPY_TYPENAME (default = 0)

        opA (opB): transposition on matrix self (B),
        'n': no transposition
        't':transpose matrix
        Return C=alpha opA(self)*opB(B)+beta*C
        """
        cdef device=self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimA=self.get_Dims()
        cdef dimB=B.get_Dims()
        if(C is None):
            dimC=np.ndarray(2,dtype=np.int64)
            dimC[0]= dimA[0] if opA=='n' else dimA[1]
            dimC[1]= dimB[1] if opB=='n' else dimB[0]
            C=obj_CLASSNAMEDIMD(ctxt=self.getContext(), dims=dimC)
        else:
            dimC=C.get_Dims()

        if(device!=B.getDevice() or
           device!=C.getDevice() ):
            raise ValueError("gemm only on the same device")

        cdef C_TYPE a
        cdef C_TYPE b
CASTSIMPLE
        a=alpha
        b=beta
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
        b.x=beta.x
        b.y=beta.y
ENDCOMPLEX

        C.c_o.gemm(ord(opA),ord(opB),a,self.c_o,dimA[0],B.c_o,dimB[0],b,dimC[0])

        return C


    def symm(self, obj_CLASSNAME2D B, str side='l', NUMPY_TYPENAME_T alpha=1,
             obj_CLASSNAME2D C=None, NUMPY_TYPENAME_T beta=0):
        """Cublas symm

        B -- obj_CLASSNAME2D
        side -- char (default = 'l')
        alpha -- NUMPY_TYPENAME (default =1)
        C -- obj_CLASSNAME2D (default = None)
        beta -- NUMPY_TYPENAME (default =0)

        return alpha*A*B+beta*C     if side='l'
               alpha*B*A+beta*C     otherwise
        """
        prodSide=CUBLAS_SIDE_LEFT if side=='l' else CUBLAS_SIDE_RIGHT

        cdef device=self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimA=self.get_Dims()
        cdef dimB=B.get_Dims()
        if(C is None):
            dimC=np.ndarray(2,dtype=np.int64)
            if(side=='l'):
                dimC[0]= dimA[0]
                dimC[1]= dimB[1]
            else:
                dimC[0]= dimA[1]
                dimC[1]= dimB[0]

            C=obj_CLASSNAMEDIMD(ctxt=self.getContext(), dims=dimC)
        else:
            dimC=C.get_Dims()

        if(device != B.getDevice() or
           device != C.getDevice() ):
            raise ValueError("symm only on the same device")

        cdef C_TYPE a
        cdef C_TYPE b
CASTSIMPLE
        a=alpha
        b=beta
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
        b.x=beta.x
        b.y=beta.y
ENDCOMPLEX
        C.c_o.symm(prodSide,CUBLAS_FILL_MODE_LOWER, a,self.c_o,dimA[0],
                    B.c_o,dimB[0],b,dimC[0])
        return C


    def syrk(self, str opA='n', NUMPY_TYPENAME_T alpha=1, obj_CLASSNAME2D C=None,
             NUMPY_TYPENAME_T beta=0):
        """Cublas syrk

        opA -- char (default = 'n')
        alpha -- NUMPY_TYPENAME (default = 1)
        C -- obj_CLASSNAME2D (default = None)
        beta -- NUMPY_TYPENAME (default = 0)

        opA: transposition on matrix self
        'n': no transposition
        't':transpose matrix
        Return alpha*opA(self)*opA(self)T+beta*C
        """

        cdef device = self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimA=self.get_Dims()
        if(C is None):
            dimC=np.ndarray(2,dtype=np.int64)
            if(opA=='n'):
                dimC[0]=dimA[0]
                dimC[1]=dimA[0]
            else:
                dimC[0]=dimA[1]
                dimC[1]=dimA[1]

            C=obj_CLASSNAMEDIMD(ctxt=self.getContext(), dims=dimC)
        else:
            dimC=C.get_Dims()

        if(device != C.getDevice()):
            raise ValueError("syrk only on the same device")

        cdef C_TYPE a
        cdef C_TYPE b
CASTSIMPLE
        a=alpha
        b=beta
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
        b.x=beta.x
        b.y=beta.y
ENDCOMPLEX
        C.c_o.syrk(CUBLAS_FILL_MODE_UPPER, ord(opA),a, self.c_o, dimA[0], b,
                    dimC[0])
        return C


    def syrkx(self, obj_CLASSNAME2D B, str opA='n',
              NUMPY_TYPENAME_T alpha=1, obj_CLASSNAME2D C=None, NUMPY_TYPENAME_T beta=0):
        """Cublas syrkx

        B -- obj_CLASSNAME2D
        opA -- char (default = 'n')
        apha -- NUMPY_TYPENAME (default = 1)
        C -- obj_CLASSNAME2D (default = None)
        beta -- NUMPY_TYPENAME (default = 0)

        opA (opB): transposition on matrix self (B),
        'n': no transposition
        't':transpose matrix
        Return alpha*opA(self)*opB(B)T+beta*C
        """
        cdef device=self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimA=self.get_Dims()
        cdef dimB=B.get_Dims()
        if(C is None):
            dimC=np.ndarray(2,dtype=np.int64)
            if(opA=='n'):
                dimC[0]=dimA[0]
                dimC[1]=dimB[0]
            else:
                dimC[0]=dimA[1]
                dimC[1]=dimB[1]
            C=obj_CLASSNAMEDIMD(self.getContext(),dims=dimC)
        else:
            dimC=C.get_Dims()

        if(device != B.getDevice() or
           device != C.getDevice() ):
            raise ValueError("syrkx only on the same device")

        cdef C_TYPE a
        cdef C_TYPE b
CASTSIMPLE
        a=alpha
        b=beta
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
        b.x=beta.x
        b.y=beta.y
ENDCOMPLEX
        C.c_o.syrkx(CUBLAS_FILL_MODE_UPPER, ord(opA),a,self.c_o,dimA[0],
                    B.c_o, dimB[0],b,dimC[0])

        return C


    def geam(self, obj_CLASSNAME2D B, NUMPY_TYPENAME_T alpha=1, NUMPY_TYPENAME_T beta=0,
             str opA='n', str opB='n', obj_CLASSNAME2D C=None):
        """Cublas geam

        B -- obj_CLASSNAME2D
        alpha -- NUMPY_TYPENAME (default = 1)
        beta -- NUMPY_TYPENAME (default = 0)
        opA -- char (default = 'n')
        opB -- char (default = 'n')
        C -- obj_CLASSNAME2D (default = None)

        opA (opB): transposition on matrix self (B),
        'n': no transposition
        't':transpose matrix
        return C= alpha*opA(self)+beta*opB(B)
        """
        cdef device=self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimA=self.get_Dims()
        cdef dimB=B.get_Dims()
        if( C is None):
            dimC=np.ndarray(2,dtype=np.int64)
            if(opA=='n'):
                dimC[0]=dimA[0]
                dimC[1]=dimA[1]
            else:
                dimC[0]=dimA[1]
                dimC[1]=dimA[0]
            C=obj_CLASSNAMEDIMD(self.getContext(),dims=dimC)
        else:
            dimC=C.get_Dims()

        if(device != B.getDevice() or
           device != C.getDevice() ):
            raise ValueError("geam only on the same device")


        cdef C_TYPE a
        cdef C_TYPE b
CASTSIMPLE
        a=alpha
        b=beta
ENDSIMPLE
CASTCOMPLEX
        a.x=alpha.x
        a.y=alpha.y
        b.x=beta.x
        b.y=beta.y
ENDCOMPLEX
        C.c_o.geam(ord(opA), ord(opB), a, self.c_o, dimA[0],
                   b, B.c_o, dimB[0], dimC[0])
        return C


    def dgmm(self, obj_CLASSNAME1D X, str sidec='l',
             obj_CLASSNAME2D C=None):
        """Cublas dgmm

        X -- obj_CLASSNAME1D
        side -- char (default = 'l')
        C -- obj_CLASSNAME2D (default = None)

        Return self*diag(X)     if sidec='l'
               diag(X)*self     otherwise
        """

        cdef device=self.getDevice()
        self.context.set_activeDevice(device)
        cdef dimA=self.get_Dims()
        cdef dimX=X.get_Dims()
        if(C is None):
            dimC=np.ndarray(2,dtype=np.int64)
            if(sidec=='l'):
                dimC[0]=dimA[0]
                dimC[1]=dimA[1]
            else:
                dimC[0]=dimA[1]
                dimC[1]=dimA[0]
            C=obj_CLASSNAMEDIMD(self.getContext(),dims=dimC)
        else:
            dimC=C.getDims()

        if(device != X.getDevice() or
           device != C.getDevice() ):
            raise ValueError("dgmm only in the same device")

        side=CUBLAS_SIDE_LEFT if sidec=='l' else CUBLAS_SIDE_RIGHT

        C.c_o.dgmm(side,self.c_o,dimA[1], X.c_o, 1, dimC[1])
        return C


    def transpose(self, obj_CLASSNAMEDIMD dest=None):
        """
        """
        cdef device=self.getDevice()
        self.context.set_activeDeviceForCpy(device)
        cdef dimA=self.getDims()
        if(dest is None):
            dimD=np.ndarray(2,dtype=np.int64)
            dimD[0]=dimA[1]
            dimD[1]=dimA[0]
            dest= obj_CLASSNAMEDIMD(self.getContext,dims=dimD)
        else:
            dimD=dest.getDims()

        if(device != dest.getDevice()):
            raise ValueError("transpose only on the same device")

        dest.c_o.transpose(self.c_o)
        return dest


'''


pxd_code_str_Ncplx = '''
    def nrm2(self):
        """Cublas nrm2. Return the Euclidean norm """
        self.context.set_activeDevice(self.getDevice())
        return self.c_o.nrm2(1)


    def asum(self):
        """Cublas asum. Return the sum of the absolute values of the data's elements """
        self.context.set_activeDeviceForCpy(self.getDevice())
        return self.c_o.asum(1)


    def sum(self):
        """Return the sum of the data's elements """
        self.context.set_activeDevice(self.getDevice())
        return self.c_o.sum()


'''


pxd_code_str_fftR = '''
    def fft(self, obj_PY_FFT_TYPEDIMD dest=None, int direction=1):
        cdef plan
        cdef cufftHandle *handle = self.c_o.getPlan()
        cdef uintptr_t output

        cdef np.ndarray ds=self.get_Dims()
        cdef np.ndarray dd

        cdef long dims_src[DIM+1]
        dims_src[0]=DIM
        for i in range(DIM):
            dims_src[i+1]=ds[i]

        if(dest is None):
            dd=self.get_Dims()
            dd[DIM-1]=dd[DIM-1]/2+1
            dest=obj_PY_FFT_TYPEDIMD(self.getContext(),dims=dd)

        try:
            plan=dict_fft_CLASSNAMEDIMD[dest.__class__]
        except KeyError:
            print("fft not available from ", self.__class__.__name__, " to ",dest.__class__.__name__)
            return

        output = dest.getData_ptr()
        carma_initfft[C_TYPE,C_FFT_TYPE](dims_src,self.c_o.getPlan(),plan)
        carma_fft[C_TYPE,C_FFT_TYPE](self.c_o.getData(), <C_FFT_TYPE*><void*>output, direction,handle[0])

        return dest

'''
pxd_code_str_fftC = '''
    def fft(self, bool inplace=False, bool C2R=False, dest=None, int direction=1):
        """Compute fft, using "cufftExec"

        dest -- obj (default = None)
        dir -- integer (default 1)

        dir: fft's direction
        if dest is None, inplace fft (only available for C2C fft)

        Return dest= fft(self,dir)
        """

        cdef plan

        cdef cufftHandle *handle = self.c_o.getPlan()
        cdef uintptr_t output

        cdef np.ndarray ds=self.get_Dims()
        cdef np.ndarray dd=self.get_Dims()

        cdef int i

        cdef long dims_src[DIM+1]
        cdef long dims_dest[DIM+1]
        dims_src[0]=DIM
        dims_dest[0]=DIM
        for i in range(DIM):
            dims_src[i+1]=ds[i]
            dims_dest[i+1]=ds[i]

        if(C2R):
            dims_dest[DIM]=(dims_dest[DIM]-1)*2
            dd[DIM-1]=(dd[DIM-1]-1)*2

        if(dest is None):
            if(inplace):
                dest=self
            else:
                if(C2R):
                    dest=obj_PY_FFT_TYPEDIMD(self.getContext(),dims=dd)
                else:
                    dest=obj_CLASSNAMEDIMD(self.getContext(),dims=dd)

        cdef t_dest=dest.__class__
        try:
            plan=dict_fft_CLASSNAMEDIMD[t_dest]
        except KeyError:
            print("fft not available from ", self.__class__.__name__, " to ",dest.__class__.__name__)
            return
        output = dest.getData_ptr()

        if(t_dest==self.__class__):
            carma_initfft[C_TYPE,C_TYPE](dims_src,self.c_o.getPlan(),plan)
            carma_fft[C_TYPE,C_TYPE](self.c_o.getData(), <C_TYPE*><void*>output, direction,handle[0])
        else:
            carma_initfft[C_TYPE,C_FFT_TYPE](dims_dest,self.c_o.getPlan(),plan)
            carma_fft[C_TYPE,C_FFT_TYPE](self.c_o.getData(), <C_FFT_TYPE*><void*>output, direction,handle[0])

        if(not inplace):
            return dest

'''

pxd_code_str_fftconv = '''
#see dims array
#dims[0]:first dimension (dims do not contain the number of dimensions)
#in code below: dims[0]:number of dimensions (folowed by dimensions)
    def fftconv_init(self, obj_FloatDIMD ker, type="real"):
        cdef dimsIm=self.get_Dims()
        cdef dimsKer=ker.get_Dims()
        cdef dims_data=np.ndarray((DIM+1),dtype=np.int64)
        cdef int i

        dims_data[0]=dimsIm[0]
        dims_data[1]=snapTransformSize(dimsIm[1]+dimsKer[2]-1)
        dims_data[2]=snapTransformSize(dimsIm[2]+dimsKer[2]-1)
        for i in range(3,DIM+1):
            dims_data[i]=dimsIm[i]
        print(dims_data)

        self.activateDevice()

        if(type=="real"):
            dest=obj_FloatDIMD(self.getContext(),dims=dims_data)
        elif(type=="complex"):
            dims_data[2]=dims_data[2]/2+1
            dest=obj_ComplexSDIMD(self.getContext(),dims=dims_data)
        else:
            raise ValueError("""argument "type" must be "real" (default) or "complex" """)

        return dest


    def fftconv(self, obj_FloatDIMD im, obj_FloatDIMD ker, obj_FloatDIMD pdata, obj_ComplexSDIMD pspec, int kernelX, int kernelY):
        dev=self.getDevice()
        if(dev !=im.getDevice() or
           dev !=ker.getDevice() or
           dev !=pdata.getDevice() or
           dev !=pspec.getDevice()
            ):
            raise ValueError("fftconv only on the same device")
        self.activateDevice()
        carma_initfftconv(im.c_o, ker.c_o, pdata.c_o, pspec.c_o, kernelY, kernelX)
        carma_fftconv(self.c_o, pdata.c_o, pspec.c_o, kernelY,kernelX)


'''

for ctype, info in c_types_info.items():

    # code available for all dimensions (constructor, getters, copy...)
    code = pxd_code_str

    if(info[0] != 'Int' and info[0] != 'UInt'):

        code += pxd_code_str2

        if(info[1] == '1'):
            # code specific to vector (cublas functions)
            code += pxd_code_str_1D

        elif(info[1] == '2'):
            # code specific to matrix (cublas functions)
            code += pxd_code_str_2D

        if(info[0] == "Float" or info[0] == "Double"):
            # code with no template (yet) for other types than float and double
            #(sum,nrm2...)
            code += pxd_code_str_Ncplx
            code += pxd_code_str_fftR

        if(info[0] == "ComplexS" or info[0] == "ComplexD"):
            code += pxd_code_str_fftC

#        if(info[0]=="Float"):
#            code+=pxd_code_str_fftconv

    if(info[5] == "SIMPLE"):
        code = re.sub("CASTSIMPLE(\n)?", "", code)
        code = re.sub("ENDSIMPLE", "", code)

        code = re.sub(r"\ *CASTCOMPLEX(.*?\n?)*?ENDCOMPLEX(\n)?", "", code)

    elif(info[5] == "COMPLEX"):
        code = re.sub(r"\ *CASTSIMPLE(.*?\n?)*?ENDSIMPLE(\n)", "", code)

        code = re.sub("CASTCOMPLEX(\n)?", "", code)
        code = re.sub("ENDCOMPLEX", "", code)

    code = code.replace(template_strs[0], info[0])
    code = code.replace(template_strs[1], info[1])
    code = code.replace(template_type_str, ctype)
    code = code.replace(template_strs[2], info[2])
    code = code.replace(template_strs[3], info[3])
    code = code.replace(template_strs[4], info[4])
    code = code.replace(template_strs[6], info[6])
    code = code.replace(template_strs[7], info[7])

    out.write(code)

?>
